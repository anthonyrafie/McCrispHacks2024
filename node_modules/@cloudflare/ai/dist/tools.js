import * as Validators from "./tasks/data/validators.js";
import { modelSettings } from "./catalog";
import { Tensor } from "./tensor";
export const debugLog = (dd, what, args) => {
    if (dd) {
        console.log(`\u001b[1m${what}`);
        if (args[0] !== false) {
            if (typeof args == "object" || Array.isArray(args)) {
                const json = JSON.stringify(args);
                console.log(json.length > 512 ? `${json.substring(0, 512)}...` : json);
            }
            else {
                console.log(args);
            }
        }
    }
};
export const validateInput = (schemaId, inputs) => {
    const valid = Validators[`#/definitions/${schemaId}`](inputs);
    if (!valid) {
        throw Validators[`#/definitions/${schemaId}`].errors.map((e) => e.message).join(",");
    }
};
export const parseInputs = (inputs) => {
    if (Array.isArray(inputs)) {
        return inputs.map((input) => input.toJSON());
    }
    if (inputs !== null && typeof inputs === "object") {
        return Object.keys(inputs).map((key) => {
            let tensor = inputs[key].toJSON();
            tensor.name = key;
            return tensor;
        });
    }
    throw new Error(`invalid inputs, must be Array<Tensor<any>> | TensorsObject`);
};
export const tensorByName = (result) => {
    const outputByName = {};
    for (let i = 0, len = result.length; i < len; i++) {
        const tensor = Tensor.fromJSON(result[i]);
        const name = tensor.name || "output" + i;
        outputByName[name] = tensor;
    }
    return outputByName;
};
export const getModelSettings = (model, key) => {
    const models = Object.keys(modelSettings);
    for (var m in models) {
        if (models[m] == model) {
            return key ? modelSettings[models[m]][key] : modelSettings[models[m]];
        }
    }
    return false;
};
export class EventSourceParserStream extends TransformStream {
    constructor() {
        let parser;
        super({
            start(controller) {
                parser = createParser((event) => {
                    if (event.type === "event") {
                        controller.enqueue(event);
                    }
                });
            },
            transform(chunk) {
                parser.feed(chunk);
            },
        });
    }
}
const BOM = [239, 187, 191];
function hasBom(buffer) {
    return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
}
export function createParser(onParse) {
    let isFirstChunk;
    let buffer;
    let startingPosition;
    let startingFieldLength;
    let eventId;
    let eventName;
    let data;
    reset();
    return { feed, reset };
    function reset() {
        isFirstChunk = true;
        buffer = "";
        startingPosition = 0;
        startingFieldLength = -1;
        eventId = undefined;
        eventName = undefined;
        data = "";
    }
    function feed(chunk) {
        buffer = buffer ? buffer + chunk : chunk;
        if (isFirstChunk && hasBom(buffer)) {
            buffer = buffer.slice(BOM.length);
        }
        isFirstChunk = false;
        const length = buffer.length;
        let position = 0;
        let discardTrailingNewline = false;
        while (position < length) {
            if (discardTrailingNewline) {
                if (buffer[position] === "\n") {
                    ++position;
                }
                discardTrailingNewline = false;
            }
            let lineLength = -1;
            let fieldLength = startingFieldLength;
            let character;
            for (let index = startingPosition; lineLength < 0 && index < length; ++index) {
                character = buffer[index];
                if (character === ":" && fieldLength < 0) {
                    fieldLength = index - position;
                }
                else if (character === "\r") {
                    discardTrailingNewline = true;
                    lineLength = index - position;
                }
                else if (character === "\n") {
                    lineLength = index - position;
                }
            }
            if (lineLength < 0) {
                startingPosition = length - position;
                startingFieldLength = fieldLength;
                break;
            }
            else {
                startingPosition = 0;
                startingFieldLength = -1;
            }
            parseEventStreamLine(buffer, position, fieldLength, lineLength);
            position += lineLength + 1;
        }
        if (position === length) {
            buffer = "";
        }
        else if (position > 0) {
            buffer = buffer.slice(position);
        }
    }
    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
        if (lineLength === 0) {
            if (data.length > 0) {
                onParse({
                    type: "event",
                    id: eventId,
                    event: eventName || undefined,
                    data: data.slice(0, -1),
                });
                data = "";
                eventId = undefined;
            }
            eventName = undefined;
            return;
        }
        const noValue = fieldLength < 0;
        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
        let step = 0;
        if (noValue) {
            step = lineLength;
        }
        else if (lineBuffer[index + fieldLength + 1] === " ") {
            step = fieldLength + 2;
        }
        else {
            step = fieldLength + 1;
        }
        const position = index + step;
        const valueLength = lineLength - step;
        const value = lineBuffer.slice(position, position + valueLength).toString();
        if (field === "data") {
            data += value ? `${value}\n` : "\n";
        }
        else if (field === "event") {
            eventName = value;
        }
        else if (field === "id" && !value.includes("\u0000")) {
            eventId = value;
        }
        else if (field === "retry") {
            const retry = parseInt(value, 10);
            if (!Number.isNaN(retry)) {
                onParse({ type: "reconnect-interval", value: retry });
            }
        }
    }
}
export class ResultStream extends TransformStream {
    constructor() {
        super({
            transform(chunk, controller) {
                if (chunk.data === "[DONE]") {
                    return;
                }
                try {
                    const data = JSON.parse(chunk.data);
                    controller.enqueue(data);
                }
                catch (err) {
                    console.error(`failed to parse incoming data (${err.stack}): ${chunk.data}`);
                    return;
                }
            },
        });
    }
}
export const getEventStream = (body) => {
    const { readable, writable } = new TransformStream();
    const eventStream = (body ?? new ReadableStream())
        .pipeThrough(new TextDecoderStream())
        .pipeThrough(new EventSourceParserStream())
        .pipeThrough(new ResultStream());
    const reader = eventStream.getReader();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();
    const write = async (data) => {
        await writer.write(encoder.encode(data));
    };
    return {
        readable,
        reader,
        writer,
        write,
    };
};
export const readStream = (body, debug, ctx, tensorData, postProcessing) => {
    const { readable, reader, writer, write } = getEventStream(body);
    const waitUntil = ctx && ctx.waitUntil ? (f) => ctx.waitUntil(f()) : (f) => f();
    waitUntil(async () => {
        try {
            for (;;) {
                const { done, value } = await reader.read();
                if (done) {
                    await write("data: [DONE]\n\n");
                    break;
                }
                debugLog(debug, "stream response", value);
                if (tensorData) {
                    const output = tensorByName(value.result);
                    await write(`data: ${JSON.stringify(postProcessing ? postProcessing(output) : output)}\n\n`);
                }
                else {
                    await write(`data: ${JSON.stringify(value)}\n\n`);
                }
            }
        }
        catch (e) {
            console.error(e.stack);
            await write("an unknown error occurred while streaming");
        }
        await writer.close();
    });
    return readable;
};
