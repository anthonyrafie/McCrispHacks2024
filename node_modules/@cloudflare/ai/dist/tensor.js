export var TensorType;
(function (TensorType) {
    TensorType["String"] = "str";
    TensorType["Bool"] = "bool";
    TensorType["Float16"] = "float16";
    TensorType["Float32"] = "float32";
    TensorType["Int16"] = "int16";
    TensorType["Int32"] = "int32";
    TensorType["Int64"] = "int64";
    TensorType["Int8"] = "int8";
    TensorType["Uint16"] = "uint16";
    TensorType["Uint32"] = "uint32";
    TensorType["Uint64"] = "uint64";
    TensorType["Uint8"] = "uint8";
})(TensorType || (TensorType = {}));
const TypedArrayProto = Object.getPrototypeOf(Uint8Array);
function isArray(value) {
    return Array.isArray(value) || value instanceof TypedArrayProto;
}
function arrLength(obj) {
    return obj instanceof TypedArrayProto
        ? obj.length
        : obj.flat(Infinity).reduce((acc, cur) => acc + (cur instanceof TypedArrayProto ? cur.length : 1), 0);
}
function ensureShape(shape, value) {
    if (shape.length === 0 && !isArray(value)) {
        return;
    }
    const count = shape.reduce((acc, v) => {
        if (!Number.isInteger(v)) {
            throw new Error(`expected shape to be array-like of integers but found non-integer element "${v}"`);
        }
        return acc * v;
    }, 1);
    if (count != arrLength(value)) {
        throw new Error(`invalid shape: expected ${count} elements for shape ${shape} but value array has length ${value.length}`);
    }
}
function ensureType(type, value) {
    if (isArray(value)) {
        value.forEach((v) => ensureType(type, v));
        return;
    }
    switch (type) {
        case TensorType.Bool: {
            if (typeof value === "boolean") {
                return;
            }
            break;
        }
        case TensorType.Float16:
        case TensorType.Float32: {
            if (typeof value === "number") {
                return;
            }
            break;
        }
        case TensorType.Int8:
        case TensorType.Uint8:
        case TensorType.Int16:
        case TensorType.Uint16:
        case TensorType.Int32:
        case TensorType.Uint32: {
            if (Number.isInteger(value)) {
                return;
            }
            break;
        }
        case TensorType.Int64:
        case TensorType.Uint64: {
            if (typeof value === "bigint") {
                return;
            }
            break;
        }
        case TensorType.String: {
            if (typeof value === "string") {
                return;
            }
            break;
        }
    }
    throw new Error(`unexpected type "${type}" with value "${value}".`);
}
function serializeType(type, value) {
    if (isArray(value)) {
        return [...value].map((v) => serializeType(type, v));
    }
    switch (type) {
        case TensorType.String:
        case TensorType.Bool:
        case TensorType.Float16:
        case TensorType.Float32:
        case TensorType.Int8:
        case TensorType.Uint8:
        case TensorType.Int16:
        case TensorType.Uint16:
        case TensorType.Uint32:
        case TensorType.Int32: {
            return value;
        }
        case TensorType.Int64:
        case TensorType.Uint64: {
            return value.toString();
        }
    }
    throw new Error(`unexpected type "${type}" with value "${value}".`);
}
function deserializeType(type, value) {
    if (isArray(value)) {
        return value.map((v) => deserializeType(type, v));
    }
    switch (type) {
        case TensorType.String:
        case TensorType.Bool:
        case TensorType.Float16:
        case TensorType.Float32:
        case TensorType.Int8:
        case TensorType.Uint8:
        case TensorType.Int16:
        case TensorType.Uint16:
        case TensorType.Uint32:
        case TensorType.Int32: {
            return value;
        }
        case TensorType.Int64:
        case TensorType.Uint64: {
            return BigInt(value);
        }
    }
    throw new Error(`unexpected type "${type}" with value "${value}".`);
}
export class Tensor {
    constructor(type, value, opts = {}) {
        this.type = type;
        this.value = value;
        ensureType(type, this.value);
        if (opts.shape === undefined) {
            if (isArray(this.value)) {
                this.shape = [arrLength(value)];
            }
            else {
                this.shape = [];
            }
        }
        else {
            this.shape = opts.shape;
        }
        ensureShape(this.shape, this.value);
        this.name = opts.name || null;
    }
    static fromJSON(obj) {
        const { type, shape, value, b64Value, name } = obj;
        const opts = { shape, name };
        if (b64Value !== undefined) {
            const value = b64ToArray(b64Value, type)[0];
            return new Tensor(type, value, opts);
        }
        else {
            return new Tensor(type, deserializeType(type, value), opts);
        }
    }
    toJSON() {
        return {
            type: this.type,
            shape: this.shape,
            name: this.name,
            value: serializeType(this.type, this.value),
        };
    }
}
function b64ToArray(base64, type) {
    const byteString = atob(base64);
    const bytes = new Uint8Array(byteString.length);
    for (let i = 0; i < byteString.length; i++) {
        bytes[i] = byteString.charCodeAt(i);
    }
    const arrBuffer = new DataView(bytes.buffer).buffer;
    switch (type) {
        case "float32":
            return new Float32Array(arrBuffer);
        case "float64":
            return new Float64Array(arrBuffer);
        case "int32":
            return new Int32Array(arrBuffer);
        case "int64":
            return new BigInt64Array(arrBuffer);
        default:
            throw Error(`invalid data type for base64 input: ${type}`);
    }
}
